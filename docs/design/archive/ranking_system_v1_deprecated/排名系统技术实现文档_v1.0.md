# 惊蛰计划第一届 - 排名系统技术实现文档

> **版本**: v1.0
> **日期**: 2025-01-06
> **作者**: 老黑(Claude)
> **状态**: 技术标准文档
> **适用**: 第一届比赛

---

## 文档说明

本文档是惊蛰计划第一届排名系统的完整技术实现规范,基于以下资料整合而成:
- 可行性研判报告(6篇技术文档分析)
- 惊蛰计划第一届评分排名系统实施方案
- 评分系统设计方案_v1.0

**核心原则**:
> "透明优于复杂,稳定优于完美"

---

## 一、系统架构总览

### 1.1 设计理念

三大支柱:
1. **可解释性** - 每个计算步骤都能用一句话向用户解释清楚
2. **抗扰动性** - 能抵御常见刷分行为,但不追求完美防御
3. **渐进公平** - 承认第一届的不完美,但确保基本公平,并承诺持续改进

### 1.2 系统流程图

```
用户评分
    ↓
[预处理层]
├── 自评过滤(自动)
├── 高危行为标记(自动+人工复核)
└── 基础完整性检查
    ↓
[资格判定层] → 未达门槛 → 显示"未达排名门槛"
    ↓ (总评分人次 > 20)
[计算核心层]
├── 截尾均值(去极端值,10%)
├── 贝叶斯平滑(防小样本偏差,k=20)
└── 并列裁决(三级tie-breaker)
    ↓
[输出层]
├── 各维度独立排名
├── "优选游戏"标识(3+维度Top10)
└── 用户可见的得分解释
```

### 1.3 与现有设计的关系

**完全兼容**:
- ✅ 革命性排名系统: 12个独立榜单
- ✅ 优选游戏机制: 3个维度前10
- ✅ 排名资格: >20人次
- ✅ 评审团权重×2: 仅影响评分人次统计
- ✅ 反作弊机制: 高危监测+高频差评检测

**新增内容**:
- 🆕 排名计算方法: 截尾均值+贝叶斯平滑
- 🆕 并列处理规则: 三级tie-breaker
- 🆕 监控指标体系: 算法健康度+公平性+性能

---

## 二、核心算法规范

### 2.1 数据预处理

#### 函数: `preprocess_ratings(game, dimension)`

**输入**:
- `game`: 游戏对象
- `dimension`: 评分维度(如"创新性")

**输出**: `(有效评分列表, 可疑评分列表, 总有效人次)`

**处理规则**:

```python
# 规则1: 排除自评
if rating.rater_id == game.creator_id:
    continue

# 规则2: 高危行为标记(仅标记,不自动排除)
if rating.is_high_risk:
    suspicious_ratings.append(rating)
    valid_ratings.append(rating)  # 仍计入,记录审计日志
    continue

# 规则3: 完整性检查
if not (0 <= rating.score <= 10):
    continue

# 规则4: 计算有效人次(评审团×2)
contestant_count = len([r for r in valid_ratings if r.rater_type == 'contestant'])
jury_count = len([r for r in valid_ratings if r.rater_type == 'jury'])
total_effective_ratings = contestant_count + 2 * jury_count
```

**关键设计**:
- 自评: 完全排除
- 高危评分: 标记但仍计入,避免误杀
- 人次计算: 评审团×2,与排名资格保持一致

---

### 2.2 排名资格判定

#### 函数: `check_ranking_eligibility(total_effective_ratings, total_games, total_jury, contestant_count, jury_count)`

**配置参数**:
```python
# 参赛者组门槛(动态)
MIN_RATINGS_ABSOLUTE = 20  # 绝对底线
MIN_RATINGS_PERCENT = 0.3  # 30%规则

# 评审团组门槛(动态)
MIN_JURY_ABSOLUTE = 5  # 绝对底线
MIN_JURY_PERCENT = 0.5  # 50%规则

# 强制评分数量
MIN_RATED_GAMES_BY_CREATOR = 10  # 参赛者必须评分的游戏数
```

**判定逻辑**:

```python
def check_ranking_eligibility(total_effective_ratings, total_games, total_jury,
                              contestant_count, jury_count, rated_games_by_creator):
    """
    排名资格判定(第一届修正版)

    新增3个检查:
    1. 参赛者是否评分了至少10个游戏
    2. 参赛者组是否达到动态门槛
    3. 评审团组是否达到动态门槛
    """

    # 检查1: 参赛者是否评分了足够的游戏(软性强制)
    if rated_games_by_creator < MIN_RATED_GAMES_BY_CREATOR:
        return {
            'eligible': False,
            'reason': f'需要评分至少{MIN_RATED_GAMES_BY_CREATOR}个游戏才能进入排名(已评分{rated_games_by_creator}个)',
            'actual_count': total_effective_ratings
        }

    # 检查2: 参赛者组动态门槛
    contestant_threshold = max(MIN_RATINGS_ABSOLUTE, int(total_games * MIN_RATINGS_PERCENT))
    if contestant_count < contestant_threshold:
        return {
            'eligible': False,
            'reason': f'参赛者评分人次不足(需要{contestant_threshold}，实际{contestant_count})',
            'actual_count': total_effective_ratings
        }

    # 检查3: 评审团组动态门槛
    jury_threshold = max(MIN_JURY_ABSOLUTE, int(total_jury * MIN_JURY_PERCENT))
    if jury_count < jury_threshold:
        return {
            'eligible': False,
            'reason': f'评审团评分人次不足(需要{jury_threshold}，实际{jury_count})',
            'actual_count': total_effective_ratings
        }

    # 所有检查通过
    return {'eligible': True}
```

**示例计算**:

```python
# 场景: 100个游戏参赛,10个评审团
check_ranking_eligibility(
    total_effective_ratings=41,
    total_games=100,
    total_jury=10,
    contestant_count=35,
    jury_count=3,
    rated_games_by_creator=12
)

# 结果: ✅ eligible=True
# - 参赛者评分了12个游戏 ≥ 10 ✓
# - 参赛者评分35人次 ≥ max(20, 100×30%=30) ✓
# - 评审团评分3人次 ≥ max(5, 10×50%=5) ✓
```

**输出**:
- 达标: 进入排名计算流程
- 未达标: 显示具体未达标原因,但仍显示原始平均分供参考

**第一届补充说明**:
- 如果参赛游戏<50个,参赛者组门槛保持20人次不变
- 参赛者必须评分≥10个游戏,自己的游戏才能排名(软性强制)

---

### 2.3 截尾均值(抗极端值)

#### 函数: `winsorized_mean(scores)`

**算法原理**:
去掉最高和最低各10%的评分,对剩余评分求算术平均。

**配置参数**:
```python
TRIM_PERCENT = 0.1  # 去掉最高和最低各10%
MIN_SAMPLES_FOR_TRIM = 10  # 少于10个评分时不截断
```

**实现逻辑**:

```python
def winsorized_mean(scores):
    n = len(scores)

    # 小样本保护
    if n < 10:
        return sum(scores) / n, {'method': 'arithmetic_mean'}

    # 计算截断数量
    k = int(n * 0.1)

    # 至少截掉1个最高分和1个最低分
    if k == 0 and n >= 10:
        k = 1

    # 排序并截断
    sorted_scores = sorted(scores)
    trimmed_scores = sorted_scores[k:n-k]

    # 计算均值
    result = sum(trimmed_scores) / len(trimmed_scores)

    return result, {
        'method': 'winsorized_mean',
        'trim_percent': 0.1,
        'trimmed_count': 2 * k,
        'original_count': n,
        'remaining_count': len(trimmed_scores)
    }
```

**示例**:
```
原始评分: [9, 9, 8, 8, 8, 7, 7, 6, 1, 1] (10个)
排序后: [1, 1, 6, 7, 7, 8, 8, 8, 9, 9]
截断: 去掉最低1个(1)和最高1个(9)
剩余: [1, 6, 7, 7, 8, 8, 8, 9]
截尾均值: 6.75分
```

**设计理由**:
- 不用中位数: 保留更多信息
- 不用Huber Mean: 避免迭代收敛问题
- 固定10%: 简单可解释

**用户可理解版本**:
> "去掉最高10%和最低10%的极端评分后,对剩余评分求平均。例如100个评分,去掉最高的10个和最低的10个,用中间80个计算平均分。"

---

### 2.4 贝叶斯平滑(防小样本偏差)

#### 函数: `bayesian_smoothing(robust_mean, effective_rating_count, global_mean)`

**算法原理**:
小样本向全局均值回归,大样本几乎不受影响。

**配置参数**:
```python
BAYESIAN_K = 20  # 平滑强度参数
```

**数学公式**:
```
S' = (n × S + k × μ) / (n + k)

其中:
- S' = 平滑后的最终得分
- S = 截尾均值
- n = 评分人次(评审团×2)
- k = 20 (平滑强度参数)
- μ = 全局平均分
```

**实现逻辑**:

```python
def bayesian_smoothing(robust_mean, effective_rating_count, global_mean):
    k = 20

    if effective_rating_count == 0:
        return global_mean, {'method': 'global_mean_only'}

    # 计算平滑后分数
    smoothed = (effective_rating_count * robust_mean + k * global_mean) / (effective_rating_count + k)

    return smoothed, {
        'method': 'bayesian_smoothing',
        'k': k,
        'global_mean': global_mean,
        'effective_rating_count': effective_rating_count,
        'influence_ratio': k / (effective_rating_count + k),  # 全局均值的影响比例
        'robust_mean': robust_mean
    }
```

**效果示例**:

假设全局平均 μ = 7.2分, k = 20

| 游戏评分人数 | 原始平均分 | 平滑后得分 | 调整幅度 | 全局均值影响 |
|-----------|----------|----------|---------|------------|
| 3人 | 9.0分 | 7.8分 | -1.2分 | 87% |
| 10人 | 8.5分 | 8.0分 | -0.5分 | 67% |
| 20人 | 8.3分 | 7.75分 | -0.55分 | 50% |
| 50人 | 8.3分 | 8.2分 | -0.1分 | 29% |
| 100人 | 8.3分 | 8.28分 | -0.02分 | 17% |

**设计理由**:
- k=20: 约需20个评分才能摆脱全局均值的一半影响
- 对于50-200人的比赛,20是合理的"可信样本"阈值

**重要说明**:
- `effective_rating_count`: 使用"人次"而非"人数"(评审团×2)
- 这与排名资格的"人次"概念保持一致

**用户可理解版本**:
> "如果你的游戏评分人数较少,我们会参考全局平均水平进行调整。例如全局平均7.2分,你的游戏只有3人评9.0分,我们会调整为7.8分,避免偶然性。随着评分人数增加,调整幅度会减小。"

---

### 2.5 全局均值计算

#### 函数: `calculate_global_mean(all_games, dimension)`

**修正说明**: 包含所有有评分的游戏,不仅限达门槛的

**实现逻辑**:

```python
def calculate_global_mean(all_games, dimension):
    robust_means = []

    for game in all_games:
        valid_ratings, _, _ = preprocess_ratings(game, dimension)

        # 只要有有效评分就计入全局均值
        if len(valid_ratings) > 0:
            scores = [r.score for r in valid_ratings]
            robust_mean, _ = winsorized_mean(scores)
            robust_means.append(robust_mean)

    if not robust_means:
        return 7.0  # 默认全局均值

    return sum(robust_means) / len(robust_means)
```

**设计理由**:
- 全局均值应该代表整体水平
- 未达门槛的游戏也应该参与全局均值计算
- 避免全局均值被"人为抬高"(好游戏更容易达门槛)

---

### 2.6 并列处理规则

#### 函数: `break_ties(game_a, game_b)`

**配置参数**:
```python
TIE_EPSILON = 0.01  # 视为并列的分数差异阈值(修正:0.001→0.01)
```

**三级Tie-breaker**:

```python
def break_ties(game_a, game_b):
    score_diff = abs(game_a['final_score'] - game_b['final_score'])

    # 大于0.01分: 不是并列
    if score_diff >= 0.01:
        return None

    # Tie-breaker 1: 评分人次多的优先
    if game_a['effective_rating_count'] != game_b['effective_rating_count']:
        return 'A' if game_a['effective_rating_count'] > game_b['effective_rating_count'] else 'B'

    # Tie-breaker 2: 方差小的优先(更稳定)
    if abs(game_a['variance'] - game_b['variance']) > 1e-6:
        return 'A' if game_a['variance'] < game_b['variance'] else 'B'

    # Tie-breaker 3: 评审团评分占比高的优先
    jury_ratio_a = game_a['jury_count'] / game_a['rating_count']
    jury_ratio_b = game_b['jury_count'] / game_b['rating_count']

    if abs(jury_ratio_a - jury_ratio_b) > 0.01:
        return 'A' if jury_ratio_a > jury_ratio_b else 'B'

    # 所有条件都相同 -> 允许并列
    return 'tie'
```

**设计理念**:
- 不修改分数本身,只影响排名顺序
- 明确的优先级顺序
- 最终可接受并列

**用户可理解版本**:
> "如果两人分数相同(差距<0.01分),我们会依次比较: 1) 评分人次多的优先; 2) 评分更稳定的优先(方差小); 3) 评审团评分占比高的优先。如果这些都相同,则允许并列排名。"

---

## 三、完整计算流程

### 3.1 单维度排名计算

#### 函数: `calculate_dimension_ranking(all_games, dimension)`

**步骤**:

```
步骤1: 计算全局均值
└── 包含所有有评分的游戏

步骤2: 计算每个游戏的最终得分
├── 2.1 预处理评分
├── 2.2 检查排名资格
├── 2.3 计算截尾均值
└── 2.4 贝叶斯平滑

步骤3: 排序(仅对排名的游戏)
└── 按final_score降序排列

步骤4: 应用tie-breaker
└── 处理同分情况

步骤5: 分配名次(考虑并列)
├── 有排名的: 显示排名(如"1", "T-2")
└── 未排名的: 显示"未达门槛"

步骤6: 返回完整结果
```

**伪代码**:

```python
def calculate_dimension_ranking(all_games, dimension):
    # 步骤1: 计算全局均值
    global_mean = calculate_global_mean(all_games, dimension)

    # 步骤2: 计算每个游戏的最终得分
    results = []
    for game in all_games:
        game_result = calculate_game_final_score(game, dimension, global_mean)
        results.append(game_result)

    # 步骤3-4: 排序并应用tie-breaker
    ranked_games = [g for g in results if g['is_ranked']]
    sorted_ranked = sort_and_apply_tie_breaker(ranked_games)

    # 步骤5: 分配名次
    assign_ranks(sorted_ranked)

    # 步骤6: 合并未排名游戏
    unranked_games = [g for g in results if not g['is_ranked']]
    return sorted_ranked + unranked_games
```

---

### 3.2 数据流转示例

**场景**: 某游戏在"创新性"维度

```
输入数据:
- 15个参赛者评分: [9, 8, 10, 7, 8, 9, 6, 10, 8, 7, 9, 10, 8, 7, 9]
- 3个评审团评分: [9, 10, 8]
- 高危标记: 0个

处理流程:

1. 预处理:
   - 有效评分: 18个
   - 评分人次: 15 + 2×3 = 21人次 ✓ 达标

2. 全局均值: 7.15分(假设)

3. 截尾均值:
   - 原始评分排序: [6, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 9, 10, 8]
   - 去掉最低1个(6)和最高1个(10)
   - 剩余16个评分的平均: 8.42分

4. 贝叶斯平滑:
   - robust_mean = 8.42
   - effective_count = 21
   - global_mean = 7.15
   - k = 20
   - smoothed = (21×8.42 + 20×7.15) / (21+20) = 7.81分

5. 输出:
   - 最终得分: 7.81分
   - 原始平均: 8.39分
   - 截尾均值: 8.42分
   - 评分人数: 18人
   - 评分人次: 21人次
```

---

## 四、配置参数规范

### 4.1 推荐配置(第一届)

```yaml
ranking_config:
  # ===== 参赛者评分资格(软性强制) =====
  min_rated_games_by_creator: 10  # 参赛者必须评分至少10个游戏

  # ===== 参赛者组门槛(动态) =====
  min_ratings_absolute: 20  # 绝对底线
  min_ratings_percent: 0.3  # 30%规则

  # ===== 评审团组门槛(动态) =====
  min_jury_absolute: 5  # 绝对底线
  min_jury_percent: 0.5  # 50%规则

  # ===== 截尾均值 =====
  trim_percent: 0.1  # 去掉最高和最低各10%
  min_samples_for_trim: 10  # 少于10个评分时不截断

  # ===== 贝叶斯平滑 =====
  bayesian_k: 20  # 平滑强度参数
  default_global_mean: 7.0  # 默认全局均值(当无数据时使用)

  # ===== 并列处理 =====
  tie_epsilon: 0.01  # 视为并列的分数差异阈值(修正后)

  # ===== 特殊处理 =====
  enable_jury_weight_in_average: false  # 评审团评分在平均分时不加权
  enable_rts: false  # 第一届不使用评分者信誉系统

  # ===== 优选游戏判定 =====
  preferred_game_min_dimensions: 3  # 至少3个维度前10
  preferred_game_only_ranked: true  # 仅计算参与排名的维度
```

**第一届补充说明**:
- 如果参赛游戏<50个,参赛者组门槛保持20人次不变
- 参赛者必须评分≥10个游戏,自己的游戏才能排名(软性强制)
- 优选游戏判定只看参与排名的维度(AI使用的维度不参与)

### 4.2 参数调优逻辑

#### 赛前预设
使用上述推荐值

#### 赛中监控
实时查看以下指标:
- **被截断的评分比例**: 如果>20%,考虑降低trim_percent
- **贝叶斯平滑影响度**: 如果大部分游戏被显著调整,考虑调整k值
- **未达门槛游戏比例**: 如果>30%,考虑降低min_ratings

#### 赛后复盘
基于实际数据重新校准所有参数

---

## 五、用户解释与透明度设计

### 5.1 得分解释卡片(U I展示)

```
作品《游戏名称》在【创新性】维度:

基础计算:
• 共收到47个有效评分(其中评审团评分3个)
• 去掉最高4个和最低4个评分(截尾10%)
• 剩余39个评分的平均分:8.42分

贝叶斯平滑:
• 该维度全局平均分:7.15分
• 由于您的评分数量(47)较多,平滑调整影响很小
• 最终得分:8.39分

当前排名:第3名(与第2名得分差0.05分)
```

### 5.2 常见问题官方解答

**Q1: 为什么我的分数和直接平均分不一样?**

> 我们使用了"截尾均值"算法,自动去除了最高和最低各10%的可能异常评分,这能防止恶意刷分对您作品的影响。具体去除了哪些评分不公开,以避免针对性攻击。

**Q2: 评分人数少会吃亏吗?**

> 对于评分人数较少的作品,我们会用"贝叶斯平滑"算法,适当参考全局平均水平进行调整。这能避免偶然的高分或低分对排名产生过大影响。随着评分人数增加,这种调整会越来越小。

**Q3: 评审团的评分权重更高吗?**

> 在计算"评分人次"时,每个评审团评分按2人次计算,这能帮助作品更快达到排名门槛。但在计算平均分时,评审团评分和参赛者评分权重相同。

**Q4: 如果两人分数相同,谁排前面?**

> 我们会依次比较: 1) 评分人次多的优先; 2) 评分更稳定的优先(方差小); 3) 评审团评分占比高的优先。如果这些都相同,则允许并列排名。

**Q5: 为什么我的游戏没有进入排名?**

> 需要获得>20人次的评分才能进入最终排名。如果未达到门槛,仍会显示平均分供参考,但不计入正式排名。第一届我们选择简单透明的规则,可能不是最完美的,但一定是最诚实的。

---

## 六、工程实施规范

### 6.1 开发任务分解

| 任务 | 工作量 | 负责人 | 交付物 | 验收标准 |
|------|--------|--------|--------|---------|
| 1. 评分预处理模块 | 1.5天 | 后端 | 评分过滤API | 通过单元测试,覆盖自评、高危标记等场景 |
| 2. 截尾均值算法 | 1天 | 后端 | 计算函数+测试 | 正确处理边界情况(小样本、极端分布) |
| 3. 贝叶斯平滑算法 | 1天 | 后端 | 计算函数+测试 | 参数可配置,性能达标 |
| 4. 并列处理逻辑 | 0.5天 | 后端 | tie-breaker函数 | 处理所有并列场景 |
| 5. 排名批处理任务 | 1.5天 | 后端 | 排名计算Job | 支持定时触发,性能满足要求 |
| 6. 数据监控看板 | 1.5天 | 数据工程师 | Grafana看板 | 包含评分分布、算法影响度等关键指标 |
| 7. 降级开关实现 | 0.5天 | SRE | 配置开关 | 可一键切换为简单平均算法 |
| 8. 用户解释文档 | 0.5天 | 产品 | FAQ页面 | 用户测试通过,无歧义 |

**总计**: 8人日

### 6.2 监控指标定义

```python
监控指标 = {
    'algorithm_health': {
        'winsorize_impact': '截尾算法影响的评分比例',
        'bayesian_adjustment': '贝叶斯平滑的平均调整幅度',
        'tie_occurrence': '发生并列的频率',
    },
    'system_fairness': {
        'rating_distribution': '评分分布(是否正态)',
        'cold_start_issue': '高质量低评分作品数量',
        'complaint_rate': '排名相关投诉率',
    },
    'performance': {
        'ranking_compute_time': '排名计算耗时',
        'api_response_time': '排名查询接口耗时',
        'memory_usage': '计算过程内存使用',
    }
}
```

### 6.3 降级与容灾方案

#### 降级策略(按优先级)

**Level 1**: 关闭贝叶斯平滑,仅使用截尾均值
- 触发条件: 用户投诉率>3%

**Level 2**: 关闭截尾均值,使用简单算术平均
- 触发条件: 连续3次排名计算失败

**Level 3**: 使用预计算的静态排名(手动上传)
- 触发条件: 系统负载超过阈值持续10分钟

#### 触发条件
- 连续3次排名计算失败
- 用户投诉率超过5%
- 系统负载超过阈值持续10分钟

---

## 七、第一届后评估与迭代路线

### 7.1 必做数据分析

比赛结束后2周内,完成以下分析:

```python
分析报告 = {
    '第一部分:算法效果验证': [
        '截尾均值去除了多少极端评分?这些评分是真的异常吗?',
        '贝叶斯平滑对多少作品产生了显著影响(>0.5分)?',
        '并列处理规则实际触发了多少次?是否合理?',
    ],
    '第二部分:公平性评估': [
        '有多少高质量作品因评分不足未进入排名?',
        '评审团评分与大众评分的一致性如何?',
        '是否有作品受到明显的恶意评分攻击?',
    ],
    '第三部分:用户体验': [
        '用户对排名规则的投诉主要集中在哪些方面?',
        '用户是否理解我们的算法解释?',
        '有多少用户认为排名结果公平?',
    ]
}
```

### 7.2 第二届优化建议(基于数据驱动)

#### 如果发现以下问题:

1. **极端评分过多** → 考虑引入Huber Mean或调整截断比例
2. **冷启动问题严重** → 考虑引入作品元数据(如作者历史表现)作为先验
3. **明显互评团证据** → 考虑引入简化版图检测算法
4. **评分质量差异大** → 考虑引入2维度的RTS(多样性与一致性)

#### 否则:
如果第一届运行良好,**不要为了创新而创新**,保持核心算法稳定,只做参数微调。

---

## 八、代码实现参考

完整代码实现请参考:
- [development/code/ranking_algorithm_corrected.py](../code/ranking_algorithm_corrected.py)

包含:
- 完整的Python实现
- 详细的注释说明
- 类型定义
- 工具函数
- 使用示例

---

## 九、与现有设计文档的对应关系

### 9.1 需要更新的章节

在 [评分系统设计方案_v1.0.md](../design/评分系统设计方案_v1.0.md) 中新增:

**5.2 排名计算方法**(新增)
```markdown
详见《排名系统技术实现文档 v1.0》第二章
```

**5.3 并列处理规则**(新增)
```markdown
详见《排名系统技术实现文档 v1.0》第2.6节
```

### 9.2 保持不变的部分

- 革命性排名系统: 12个独立榜单
- 优选游戏机制: 3个维度前10
- 排名资格: >20人次
- 评审团权重×2: 仅影响评分人次统计
- 反作弊机制: 高危监测+高频差评检测

---

## 十、附录

### 10.1 术语对照表

| 技术术语 | 用户可理解版本 |
|---------|--------------|
| Winsorized Mean | 截尾均值(去掉最高和最低各10%) |
| Bayesian Smoothing | 贝叶斯平滑(小样本向全局平均回归) |
| Effective Rating Count | 评分人次(评审团×2) |
| Trim Percent | 截断比例(10%) |
| Tie-breaker | 同分裁决规则 |

### 10.2 关键数字速查

| 参数 | 数值 | 说明 |
|------|------|------|
| **min_ratings** | 20人次 | 排名资格门槛 |
| **trim_percent** | 10% | 截尾比例 |
| **min_samples_for_trim** | 10个 | 少于此数量不截断 |
| **bayesian_k** | 20 | 平滑强度参数 |
| **tie_epsilon** | 0.01分 | 并列判定阈值 |
| **default_global_mean** | 7.0分 | 默认全局均值 |

### 10.3 实施承诺

**向用户承诺**:

> "第一届,我们选择简单透明的算法,可能不是最完美的,但一定是最诚实的。我们会完整记录所有数据,并在赛后公开分析报告。您的每一次评分,都在帮助我们让下一届更公平。"

---

**文档结束**

**版本**: v1.0
**最后更新**: 2025-01-06
**维护人**: 老黑(Claude)
